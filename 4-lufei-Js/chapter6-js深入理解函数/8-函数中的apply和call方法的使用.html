<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>8-函数中的apply和call方法的使用</title>
	</head>
	<body>
		<script type="text/javascript">
            // function fn(){};
            // var obj = new fn();
            // fn.prototype.a = 1; //prototype 拥有继承性
            // console.log(obj);


            //apply() call()
            //call({},1,2,3)
            //apply({},[])
            //每个函数都包含两个非继承而来的方法
            // window.color = 'red';
            // console.log(window);
            // var obj = {color:'blue'};

            // function sayColor(){
            //     console.log(this.color);//无返回值且返回值不是对象this为window
            // }
            // sayColor();//red 因为当前的this指向了window
            // sayColor.call(this);//red
            // sayColor.call(window);//red
            // sayColor.call(obj);//this 指向了obj  //blue
            
            //在非严格模式下，如果我们使用call()或者时apply()方法，
            //传入一个null 或者undefined会被转换成一个window对象
            //在严格模式下，函数的指向始终是指定的值。
            var color = 'red';
            function displayColor(){
                'use strict';
                console.log(this); //null
                console.log(this.color);   
            }
            displayColor.call(null);
        </script>
	</body>
</html>
